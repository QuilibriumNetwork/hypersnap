use crate::consensus::consensus::{Config, MalachiteEventShard};
use crate::consensus::hyper_proposer::HyperProposer;
use crate::consensus::malachite::network_connector::MalachiteNetworkEvent;
use crate::consensus::malachite::spawn::MalachiteConsensusActors;
use crate::consensus::proposer::{BlockProposer, ShardProposer};
use crate::consensus::validator::ShardValidator;
use crate::core::types::{Address, ShardId, SnapchainShard, SnapchainValidatorContext};
use crate::mempool::mempool::MempoolMessagesRequest;
use crate::network::gossip::GossipEvent;
use crate::proto::{Block, FarcasterNetwork, HyperChunk, ShardChunk};
use crate::storage::constants::HYPER_SHARD_ID;
use crate::storage::db::RocksDB;
use crate::storage::store::backfill;
use crate::storage::store::block_engine::{BlockEngine, BlockStores};
use crate::storage::store::engine::{PostCommitMessage, Senders, ShardEngine};
use crate::storage::store::hyper_engine::{HyperEngine, SnapchainAnchor};
use crate::storage::store::node_local_state::LocalStateStore;
use crate::storage::store::stores::StoreLimits;
use crate::storage::store::stores::Stores;
use crate::storage::trie::merkle_trie::{self, MerkleTrie};
use crate::utils::block_event_fix::reconcile_heartbeat_events;
use crate::utils::statsd_wrapper::StatsdClientWrapper;
use informalsystems_malachitebft_metrics::SharedRegistry;
use libp2p::identity::ed25519::Keypair;
use libp2p::PeerId;
use std::collections::{BTreeMap, HashMap};
use std::sync::Arc;
use tokio::sync::{broadcast, mpsc, watch};
use tracing::warn;

const MAX_SHARDS: u32 = 64;

#[derive(Clone)]
pub struct SnapchainNode {
    pub consensus_actors: BTreeMap<u32, MalachiteConsensusActors>,
    pub shard_stores: HashMap<u32, Stores>,
    pub shard_senders: HashMap<u32, Senders>,
    pub block_stores: BlockStores,
    /// Send snapchain anchor updates when blocks are committed.
    pub anchor_tx: watch::Sender<SnapchainAnchor>,
    pub address: Address,
}

impl SnapchainNode {
    pub async fn create(
        keypair: Keypair,
        config: Config,
        local_peer_id: PeerId,
        gossip_tx: mpsc::Sender<GossipEvent<SnapchainValidatorContext>>,
        shard_decision_tx: broadcast::Sender<ShardChunk>,
        hyper_decision_tx: broadcast::Sender<HyperChunk>,
        block_tx: Option<broadcast::Sender<Block>>,
        messages_request_tx: mpsc::Sender<MempoolMessagesRequest>,
        local_state_store: LocalStateStore,
        rocksdb_dir: String,
        statsd_client: StatsdClientWrapper,
        network: FarcasterNetwork,
        registry: &SharedRegistry,
        engine_post_commit_tx: Option<mpsc::Sender<PostCommitMessage>>,
    ) -> Self {
        let validator_address = Address(keypair.public().to_bytes());

        // Create anchor channel for snapchain â†’ hyper anchoring
        let (anchor_tx, anchor_rx) = watch::channel(SnapchainAnchor::default());

        // Create block engine first (needed for block_stores reference)
        let block_shard = SnapchainShard::new(0);
        let trie = MerkleTrie::new().unwrap();
        let block_db = RocksDB::open_shard_db(rocksdb_dir.as_str(), 0);
        let engine = BlockEngine::new(
            trie,
            statsd_client.clone(),
            block_db,
            config.max_messages_per_block,
            Some(messages_request_tx.clone()),
            network,
        );
        let block_stores = engine.stores();

        let mut consensus_actors = BTreeMap::new();

        let mut shard_senders: HashMap<u32, Senders> = HashMap::new();
        let mut shard_stores: HashMap<u32, Stores> = HashMap::new();

        // Create the shard validators
        for shard_id in config.shard_ids.clone() {
            if shard_id == 0 {
                panic!("Shard ID 0 is reserved for the block shard, created automaticaly");
            } else if shard_id > MAX_SHARDS {
                panic!("Shard ID must be between 1 and {}", MAX_SHARDS);
            }

            let shard = SnapchainShard::new(shard_id);
            let ctx = SnapchainValidatorContext::new(keypair.clone());

            let db = RocksDB::open_shard_db(rocksdb_dir.clone().as_str(), shard_id);
            let trie = merkle_trie::MerkleTrie::new().unwrap(); //TODO: don't unwrap()
            let engine = match ShardEngine::new(
                db.clone(),
                network,
                trie,
                shard_id,
                StoreLimits::default(),
                statsd_client.clone(),
                config.max_messages_per_block,
                Some(messages_request_tx.clone()),
                None,
                engine_post_commit_tx.clone(),
            )
            .await
            {
                Ok(engine) => engine,
                Err(err) => {
                    panic!(
                        "Failed to create shard engine for shard {}: {}",
                        shard_id, err
                    );
                }
            };

            shard_senders.insert(shard_id, engine.get_senders());
            shard_stores.insert(shard_id, engine.get_stores());

            if config.reconcile_heartbeat_event != 0 {
                if let Err(err) = reconcile_heartbeat_events(
                    block_stores.clone(),
                    engine.get_stores(),
                    config.reconcile_heartbeat_event,
                )
                .await
                {
                    warn!(
                        "Unable to reconcile heartbeat events {:#?}",
                        err.to_string()
                    )
                }
            }

            let shard_proposer = ShardProposer::new(
                validator_address.clone(),
                shard.clone(),
                engine,
                statsd_client.clone(),
                shard_decision_tx.clone(),
            );

            let validator_sets = config.get_validator_set_config(shard_id);
            let shard_validator = ShardValidator::new(
                validator_address.clone(),
                shard.clone(),
                validator_sets,
                None,
                Some(shard_proposer),
                None,
                local_state_store.clone(),
                statsd_client.clone(),
            );
            let consensus_actor = MalachiteConsensusActors::create_and_start(
                ctx,
                shard_validator,
                local_peer_id,
                rocksdb_dir.clone(),
                gossip_tx.clone(),
                registry,
                config.clone(),
                statsd_client.clone(),
            )
            .await;

            if consensus_actor.is_err() {
                panic!("Failed to create consensus actor for shard {}", shard_id);
            }

            consensus_actors.insert(shard_id, consensus_actor.unwrap());
        }

        // Run backfill for each shard (populates hyper trie before HyperEngine init)
        if let Some(shard_1_stores) = shard_stores.get(&1) {
            let hyper_db = shard_1_stores.db.clone();
            for shard_id in config.shard_ids.clone() {
                if let Some(stores) = shard_stores.get(&shard_id) {
                    backfill::run_backfill(stores, &hyper_db);
                }
            }
        }

        // Create the hyper engine and consensus actor
        // Share RocksDB with shard 1 (same DB, different key prefixes)
        if let Some(shard_1_stores) = shard_stores.get(&1) {
            let hyper_db = shard_1_stores.db.clone();
            let hyper_shard = SnapchainShard::new(HYPER_SHARD_ID);

            let hyper_engine = match HyperEngine::new(
                hyper_db,
                network,
                HYPER_SHARD_ID,
                shard_1_stores.clone(),
                anchor_rx,
                Some(messages_request_tx.clone()),
                config.max_messages_per_block,
                statsd_client.clone(),
            ) {
                Ok(engine) => engine,
                Err(err) => {
                    panic!("Failed to create hyper engine: {}", err);
                }
            };

            let hyper_proposer = HyperProposer::new(
                validator_address.clone(),
                hyper_shard.clone(),
                hyper_engine,
                statsd_client.clone(),
                hyper_decision_tx,
            );

            let hyper_validator_sets = config.get_validator_set_config(HYPER_SHARD_ID);
            let hyper_validator = ShardValidator::new(
                validator_address.clone(),
                hyper_shard.clone(),
                hyper_validator_sets,
                None,
                None,
                Some(hyper_proposer),
                local_state_store.clone(),
                statsd_client.clone(),
            );

            let ctx = SnapchainValidatorContext::new(keypair.clone());
            let hyper_consensus_actor = MalachiteConsensusActors::create_and_start(
                ctx,
                hyper_validator,
                local_peer_id,
                rocksdb_dir.clone(),
                gossip_tx.clone(),
                registry,
                config.clone(),
                statsd_client.clone(),
            )
            .await;

            if hyper_consensus_actor.is_err() {
                panic!("Failed to create consensus actor for hyper shard");
            }
            consensus_actors.insert(HYPER_SHARD_ID, hyper_consensus_actor.unwrap());
        }

        // Now create the block validator
        let block_shard = SnapchainShard::new(0);

        let trie = MerkleTrie::new().unwrap();
        let block_db = RocksDB::open_shard_db(rocksdb_dir.as_str(), 0);
        let engine = BlockEngine::new(
            trie,
            statsd_client.clone(),
            block_db,
            config.max_messages_per_block,
            Some(messages_request_tx.clone()),
            network,
        );
        let block_stores = engine.stores();
        let block_proposer = BlockProposer::new(
            validator_address.clone(),
            block_shard.clone(),
            shard_stores.clone(),
            config.num_shards,
            network,
            block_tx,
            engine,
            statsd_client.clone(),
        );
        let validator_sets = config.get_validator_set_config(0);
        let block_validator = ShardValidator::new(
            validator_address.clone(),
            block_shard.clone(),
            validator_sets,
            Some(block_proposer),
            None,
            None,
            local_state_store,
            statsd_client.clone(),
        );
        let ctx = SnapchainValidatorContext::new(keypair.clone());
        let block_consensus_actor = MalachiteConsensusActors::create_and_start(
            ctx,
            block_validator,
            local_peer_id,
            rocksdb_dir.clone(),
            gossip_tx.clone(),
            registry,
            config,
            statsd_client.clone(),
        )
        .await;
        if block_consensus_actor.is_err() {
            panic!("Failed to create consensus actor for block shard");
        }
        consensus_actors.insert(0, block_consensus_actor.unwrap());

        Self {
            consensus_actors,
            address: validator_address,
            shard_senders,
            shard_stores,
            block_stores,
            anchor_tx,
        }
    }

    pub fn id(&self) -> String {
        self.address.prefix()
    }

    pub fn stop(&self) {
        // Stop all actors
        for (_, actor) in self.consensus_actors.iter() {
            actor.stop();
        }
    }

    pub fn dispatch(&self, shard: MalachiteEventShard, event: MalachiteNetworkEvent) {
        match shard {
            MalachiteEventShard::None => {
                for (shard_index, actor) in self.consensus_actors.iter() {
                    let result = actor.cast_network_event(event.clone());
                    if let Err(e) = result {
                        warn!(
                            "Failed to forward message to actor: {:?} at shard: {:?}",
                            e, shard_index
                        );
                    }
                }
            }
            MalachiteEventShard::Shard(shard_index) => {
                if let Some(actor) = self.consensus_actors.get(&shard_index) {
                    let result = actor.cast_network_event(event);
                    if let Err(e) = result {
                        warn!("Failed to forward message to actor: {:?}", e);
                    }
                } else {
                    warn!("No actor found for shard, could not forward message");
                }
            }
        }
    }
}
